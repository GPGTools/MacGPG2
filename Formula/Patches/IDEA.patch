diff -Nur cipher/cipher.c cipher/cipher.c
--- cipher/cipher.c	2010-07-13 16:06:07.000000000 +0200
+++ cipher/cipher.c	2011-12-22 12:45:02.000000000 +0100
@@ -71,6 +71,10 @@
     { &_gcry_cipher_spec_cast5,      
       &dummy_extra_spec,                  GCRY_CIPHER_CAST5 },
 #endif
+#ifdef USE_IDEA
+    { &_gcry_cipher_spec_idea,
+      &dummy_extra_spec,	          GCRY_CIPHER_IDEA },
+#endif
 #if USE_AES
     { &_gcry_cipher_spec_aes,        
       &_gcry_cipher_extraspec_aes,        GCRY_CIPHER_AES,    1 },


diff -Nur config.h.in config.h.in
--- config.h.in	2010-07-13 17:42:53.000000000 +0200
+++ config.h.in	2011-12-22 12:45:02.000000000 +0100
@@ -300,6 +294,9 @@
 #undef USE_GNU_PTH
 
 /* Defined if this module should be included */
+#undef USE_IDEA
+
+/* Defined if this module should be included */
 #undef USE_MD4
 
 /* Defined if this module should be included */


diff -Nur configure configure
--- configure	2011-06-29 10:58:02.000000000 +0200
+++ configure	2011-12-22 20:49:49.000000000 +0100
@@ -11835,6 +11835,27 @@
 # Definitions for symmetric ciphers.
 available_ciphers="arcfour blowfish cast5 des aes twofish serpent rfc2268 seed"
 available_ciphers="$available_ciphers camellia"
+as_ac_File=`$as_echo "ac_cv_file_"cipher/idea.c"" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for \"cipher/idea.c\"" >&5
+$as_echo_n "checking for \"cipher/idea.c\"... " >&6; }
+if eval \${$as_ac_File+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  test "$cross_compiling" = yes &&
+  as_fn_error $? "cannot check for file existence when cross compiling" "$LINENO" 5
+if test -r ""cipher/idea.c""; then
+  eval "$as_ac_File=yes"
+else
+  eval "$as_ac_File=no"
+fi
+fi
+eval ac_res=\$$as_ac_File
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_File"\" = x"yes"; then :
+  available_ciphers="$available_ciphers idea"
+fi
+
 enabled_ciphers=""
 
 # Definitions for public-key ciphers.
@@ -15258,6 +15279,24 @@
 fi
 
 
+name=idea
+list=$enabled_ciphers
+found=0
+
+for n in $list; do
+  if test "x$name" = "x$n"; then
+    found=1
+  fi
+done
+
+if test "$found" = "1" ; then
+   GCRYPT_CIPHERS="$GCRYPT_CIPHERS idea.lo"
+
+$as_echo "#define USE_IDEA 1" >>confdefs.h
+
+fi
+
+
 name=dsa
 list=$enabled_pubkey_ciphers
 found=0


diff -Nur src/cipher.h src/cipher.h
--- src/cipher.h	2010-07-09 09:21:23.000000000 +0200
+++ src/cipher.h	2011-12-22 12:45:02.000000000 +0100
@@ -95,6 +95,10 @@
 extern gcry_cipher_spec_t _gcry_cipher_spec_camellia192;
 extern gcry_cipher_spec_t _gcry_cipher_spec_camellia256;
 
+#ifdef USE_IDEA
+extern gcry_cipher_spec_t _gcry_cipher_spec_idea;
+#endif
+
 extern cipher_extra_spec_t _gcry_cipher_extraspec_tripledes;
 extern cipher_extra_spec_t _gcry_cipher_extraspec_aes;
 extern cipher_extra_spec_t _gcry_cipher_extraspec_aes192;


diff -Nurp cipher/idea.c cipher/idea.c
--- cipher/idea.c	1970-01-01 02:00:00.000000000 +0200
+++ cipher/idea.c	2007-02-02 15:19:40.000000000 +0200
@@ -0,0 +1,272 @@
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h> /* for memcmp() */
+#include <assert.h>
+
+#include "types.h"  /* for byte and u32 typedefs */
+#include "g10lib.h"
+#include "cipher.h"
+
+/* configuration stuff */
+#ifdef __alpha__
+  #define SIZEOF_UNSIGNED_LONG 8
+#else
+  #define SIZEOF_UNSIGNED_LONG 4
+#endif
+
+#if defined(__mc68000__) || defined (__sparc__) || defined (__PPC__) \
+    || (defined(__mips__) && (defined(MIPSEB) || defined (__MIPSEB__)) ) \
+    || defined(__powerpc__) \
+    || defined(__hpux__) /* should be replaced by the Macro for the PA */
+  #define BIG_ENDIAN_HOST 1
+#else
+  #define LITTLE_ENDIAN_HOST 1
+#endif
+
+#ifndef DIM
+  #define DIM(v) (sizeof(v)/sizeof((v)[0]))
+  #define DIMof(type,member)   DIM(((type *)0)->member)
+#endif
+
+/* imports */
+void g10_log_fatal( const char *fmt, ... );
+
+
+/* local stuff */
+
+#define FNCCAST_SETKEY(f)  ((int(*)(void*, byte*, unsigned))(f))
+#define FNCCAST_CRYPT(f)   ((void(*)(void*, byte*, byte*))(f))
+
+#define IDEA_KEYSIZE 16
+#define IDEA_BLOCKSIZE 8
+#define IDEA_ROUNDS 8
+#define IDEA_KEYLEN (6*IDEA_ROUNDS+4)
+
+typedef struct {
+    u16 ek[IDEA_KEYLEN];
+    u16 dk[IDEA_KEYLEN];
+    int have_dk;
+} IDEA_context;
+
+static u16
+mul_inv( u16 x )
+{
+    u16 t0, t1;
+    u16 q, y;
+
+    if( x < 2 )
+	return x;
+    t1 = 0x10001L / x;
+    y =  0x10001L % x;
+    if( y == 1 )
+	return (1-t1) & 0xffff;
+
+    t0 = 1;
+    do {
+	q = x / y;
+	x = x % y;
+	t0 += q * t1;
+	if( x == 1 )
+	    return t0;
+	q = y / x;
+	y = y % x;
+	t1 += q * t0;
+    } while( y != 1 );
+    return (1-t1) & 0xffff;
+}
+
+static void
+cipher( byte *outbuf, const byte *inbuf, u16 *key )
+{
+    u16 x1, x2, x3,x4, s2, s3;
+    u16 *in, *out;
+    int r = IDEA_ROUNDS;
+  #define MUL(x,y) \
+	do {u16 _t16; u32 _t32; 		    \
+	    if( (_t16 = (y)) ) {		    \
+		if( (x = (x)&0xffff) ) {	    \
+		    _t32 = (u32)x * _t16;	    \
+		    x = _t32 & 0xffff;		    \
+		    _t16 = _t32 >> 16;		    \
+		    x = ((x)-_t16) + (x<_t16?1:0);  \
+		}				    \
+		else {				    \
+		    x = 1 - _t16;		    \
+		}				    \
+	    }					    \
+	    else {				    \
+		x = 1 - x;			    \
+	    }					    \
+	} while(0)
+
+    in = (u16*)inbuf;
+    x1 = *in++;
+    x2 = *in++;
+    x3 = *in++;
+    x4 = *in;
+  #ifdef LITTLE_ENDIAN_HOST
+    x1 = (x1>>8) | (x1<<8);
+    x2 = (x2>>8) | (x2<<8);
+    x3 = (x3>>8) | (x3<<8);
+    x4 = (x4>>8) | (x4<<8);
+  #endif
+    do {
+	MUL(x1, *key++);
+	x2 += *key++;
+	x3 += *key++;
+	MUL(x4, *key++ );
+
+	s3 = x3;
+	x3 ^= x1;
+	MUL(x3, *key++);
+	s2 = x2;
+	x2 ^=x4;
+	x2 += x3;
+	MUL(x2, *key++);
+	x3 += x2;
+
+	x1 ^= x2;
+	x4 ^= x3;
+
+	x2 ^= s3;
+	x3 ^= s2;
+    } while( --r );
+    MUL(x1, *key++);
+    x3 += *key++;
+    x2 += *key++;
+    MUL(x4, *key);
+
+    out = (u16*)outbuf;
+  #ifdef LITTLE_ENDIAN_HOST
+    *out++ = (x1>>8) | (x1<<8);
+    *out++ = (x3>>8) | (x3<<8);
+    *out++ = (x2>>8) | (x2<<8);
+    *out   = (x4>>8) | (x4<<8);
+  #else
+    *out++ = x1;
+    *out++ = x3;
+    *out++ = x2;
+    *out   = x4;
+  #endif
+  #undef MUL
+}
+
+static void
+expand_key( const byte *userkey, u16 *ek )
+{
+    int i,j;
+
+    for(j=0; j < 8; j++ ) {
+	ek[j] = (*userkey << 8) + userkey[1];
+	userkey += 2;
+    }
+    for(i=0; j < IDEA_KEYLEN; j++ ) {
+	i++;
+	ek[i+7] = ek[i&7] << 9 | ek[(i+1)&7] >> 7;
+	ek += i & 8;
+	i &= 7;
+    }
+}
+
+static void
+invert_key( u16 *ek, u16 dk[IDEA_KEYLEN] )
+{
+    int i;
+    u16 t1, t2, t3;
+    u16 temp[IDEA_KEYLEN];
+    u16 *p = temp + IDEA_KEYLEN;
+
+    t1 = mul_inv( *ek++ );
+    t2 = -*ek++;
+    t3 = -*ek++;
+    *--p = mul_inv( *ek++ );
+    *--p = t3;
+    *--p = t2;
+    *--p = t1;
+
+    for(i=0; i < IDEA_ROUNDS-1; i++ ) {
+	t1 = *ek++;
+	*--p = *ek++;
+	*--p = t1;
+
+	t1 = mul_inv( *ek++ );
+	t2 = -*ek++;
+	t3 = -*ek++;
+	*--p = mul_inv( *ek++ );
+	*--p = t2;
+	*--p = t3;
+	*--p = t1;
+    }
+    t1 = *ek++;
+    *--p = *ek++;
+    *--p = t1;
+
+    t1 = mul_inv( *ek++ );
+    t2 = -*ek++;
+    t3 = -*ek++;
+    *--p = mul_inv( *ek++ );
+    *--p = t3;
+    *--p = t2;
+    *--p = t1;
+    memcpy(dk, temp, sizeof(temp) );
+    memset(temp, 0, sizeof(temp) );  /* burn temp */
+}
+
+static int
+do_idea_setkey( IDEA_context *c, const byte *key, unsigned int keylen )
+{
+    assert(keylen == 16);
+    c->have_dk = 0;
+    expand_key( key, c->ek );
+    invert_key( c->ek, c->dk );
+    return 0;
+}
+
+static gcry_err_code_t
+idea_setkey (void *context, const byte *key, unsigned int keylen)
+{
+  IDEA_context *ctx = context;
+  int rc = do_idea_setkey (ctx, key, keylen);
+  _gcry_burn_stack (23+6*sizeof(void*));
+  return rc;
+}
+
+static void
+do_idea_encrypt( IDEA_context *c, byte *outbuf, const byte *inbuf )
+{
+    cipher( outbuf, inbuf, c->ek );
+}
+
+static void
+idea_encrypt (void *context, byte *out, const byte *in)
+{
+  IDEA_context *ctx = context;
+  do_idea_encrypt (ctx, out, in);
+  _gcry_burn_stack (24+3*sizeof (void*));
+}
+
+static void
+do_idea_decrypt( IDEA_context *c, byte *outbuf, const byte *inbuf )
+{
+    if( !c->have_dk ) {
+       c->have_dk = 1;
+       invert_key( c->ek, c->dk );
+    }
+    cipher( outbuf, inbuf, c->dk );
+}
+
+static void
+idea_decrypt (void *context, byte *out, const byte *in)
+{
+  IDEA_context *ctx = context;
+
+  do_idea_decrypt (ctx, out, in);
+  _gcry_burn_stack (24+3*sizeof (void*));
+}
+
+gcry_cipher_spec_t _gcry_cipher_spec_idea =
+  {
+    "IDEA", NULL, NULL, IDEA_BLOCKSIZE, 128, sizeof (IDEA_context),
+    idea_setkey, idea_encrypt, idea_decrypt,
+  };

