# This patch adds cacheid to gpg-agent. This is needed for the Mac OS X keychain.

diff -ru agent/agent.h agent/agent.h
--- agent/agent.h	2011-01-09 23:06:14.000000000 +0100
+++ agent/agent.h	2011-12-22 12:45:02.000000000 +0100
@@ -253,7 +253,7 @@
                   struct pin_entry_info_s *pininfo);
 int agent_get_passphrase (ctrl_t ctrl, char **retpass,
                           const char *desc, const char *prompt,
-                          const char *errtext, int with_qualitybar);
+                          const char *errtext, int with_qualitybar, const char *cacheid);
 int agent_get_confirmation (ctrl_t ctrl, const char *desc, const char *ok,
 			    const char *notokay, int with_cancel);
 int agent_show_message (ctrl_t ctrl, const char *desc, const char *ok_btn);


diff -ru agent/call-pinentry.c agent/call-pinentry.c
--- agent/call-pinentry.c	2011-01-09 23:06:14.000000000 +0100
+++ agent/call-pinentry.c	2011-12-22 12:45:02.000000000 +0100
@@ -843,7 +843,7 @@
 int 
 agent_get_passphrase (ctrl_t ctrl,
                       char **retpass, const char *desc, const char *prompt,
-                      const char *errtext, int with_qualitybar)
+                      const char *errtext, int with_qualitybar, const char *cacheid)
 {
 
   int rc;
@@ -859,6 +859,15 @@
   if (rc)
     return rc;
 
+	
+  if (cacheid) {
+    snprintf (line, DIM(line)-1, "OPTION cache-id=%s", cacheid);
+    rc = assuan_transact (entry_ctx, line, NULL, NULL, NULL, NULL, NULL, NULL);
+    if (rc)
+      return unlock_pinentry (rc);
+  }
+	
+	
   if (!prompt)
     prompt = desc && strstr (desc, "PIN")? "PIN": _("Passphrase");


diff -ru agent/command.c agent/command.c
--- agent/command.c	2011-01-09 23:06:14.000000000 +0100
+++ agent/command.c	2011-12-22 12:45:02.000000000 +0100
@@ -1121,7 +1121,7 @@
     next_try:
       rc = agent_get_passphrase (ctrl, &response, desc, prompt,
                                  repeat_errtext? repeat_errtext:errtext,
-                                 opt_qualbar);
+                                 opt_qualbar, cacheid);
       xfree (repeat_errtext);
       repeat_errtext = NULL;
       if (!rc)
@@ -1138,7 +1138,7 @@
               char *response2;
 
               rc = agent_get_passphrase (ctrl, &response2, desc2, prompt,
-                                         errtext, 0);
+                                         errtext, 0, cacheid);
               if (rc)
                 break;
               if (strcmp (response2, response))
diff -ru g10/seckey-cert.c g10/seckey-cert.c
--- g10/seckey-cert.c	2011-01-09 23:06:16.000000000 +0100
+++ g10/seckey-cert.c	2011-12-22 12:45:02.000000000 +0100
@@ -209,6 +209,13 @@
                 csum += checksum (buffer, ndata);
                 gcry_mpi_release (sk->skey[i]);
 
+		/* Alon Bar-Lev's IDEA patch - needed as the raw key has
+		    two bits which are part of the checksum and not the key */
+		if (CIPHER_ALGO_IDEA == sk->protect.algo) {
+			buffer[0] = 0;
+			buffer[1] = 0;
+		}
+
 		err = gcry_mpi_scan( &sk->skey[i], GCRYMPI_FMT_PGP,
 				     buffer, ndata, &ndata );
 		xfree (buffer);
diff -ru g10/keygen.c g10/keygen.c
--- g10/keygen.c	2011-01-10 19:09:46.000000000 +0100
+++ g10/keygen.c	2011-12-22 12:45:02.000000000 +0100
@@ -1774,14 +1774,20 @@
 static unsigned
 ask_keysize (int algo, unsigned int primary_keysize)
 {
-  unsigned int nbits, min, def = DEFAULT_STD_KEYSIZE, max=4096;
+  unsigned int nbits, min, def = DEFAULT_STD_KEYSIZE, max;
   int for_subkey = !!primary_keysize;
   int autocomp = 0;
 
   if(opt.expert)
-    min=512;
+    {
+      min=512;
+      max=8192;
+    }
   else
-    min=1024;
+    {
+      min=1024;
+      max=4096;
+    }
 
   if (primary_keysize && !opt.expert)
     {
diff -ru agent/gpg-agent.c agent/gpg-agent.c
--- agent/gpg-agent.c	2011-01-09 23:06:14.000000000 +0100
+++ agent/gpg-agent.c	2011-12-22 12:45:02.000000000 +0100
@@ -37,6 +37,10 @@
 #include <unistd.h>
 #include <signal.h>
 #include <pth.h>
+#define HAVE_LAUNCH 1
+#ifdef HAVE_LAUNCH
+# include <launch.h>
+#endif
 
 #define JNLIB_NEED_LOG_LOGV
 #define JNLIB_NEED_AFLOCAL
@@ -74,6 +78,9 @@
   oLogFile,
   oServer,
   oDaemon,
+#ifdef HAVE_LAUNCH
+  oLaunchd,
+#endif
   oBatch,
 
   oPinentryProgram,
@@ -121,6 +128,9 @@
 
   { oServer,   "server",     0, N_("run in server mode (foreground)") },
   { oDaemon,   "daemon",     0, N_("run in daemon mode (background)") },
+#ifdef HAVE_LAUNCH
+  { oLaunchd,   "launchd",   0, N_("run in the foreground, under launched control") },
+#endif
   { oVerbose, "verbose",     0, N_("verbose") },
   { oQuiet,	"quiet",     0, N_("be somewhat more quiet") },
   { oSh,	"sh",        0, N_("sh-style command output") },
@@ -440,6 +450,63 @@
 {
   remove_socket (socket_name);
   remove_socket (socket_name_ssh);
+#ifdef HAVE_LAUNCH
+  // Remove environment variables back from launchd.
+  launch_data_t resp, tmp, msg;
+
+  msg = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+
+  tmp = launch_data_new_string("GPG_AGENT_INFO");
+  launch_data_dict_insert(msg, tmp, "UnsetUserEnvironment");
+
+  resp = launch_msg(msg);
+  launch_data_free(msg); // Do NOT launch_data_free() on tmp
+
+  if (resp) 
+    {
+      launch_data_free(resp);
+    } 
+  else
+    {
+      log_error ("failed to remove environment variable GPG_AGENT_INFO from launchd: %s\n", strerror (errno));
+    }         
+
+  if (opt.ssh_support)
+    {
+      msg = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+
+      tmp = launch_data_new_string("SSH_AUTH_SOCK");
+      launch_data_dict_insert(msg, tmp, "UnsetUserEnvironment");
+
+      resp = launch_msg(msg);
+      launch_data_free(msg); // Do NOT launch_data_free() on tmp
+
+      if (resp) 
+        {
+          launch_data_free(resp);
+        } 
+      else
+        {
+          log_error ("failed to remove environment variable SSH_AUTH_SOCK from launchd: %s\n", strerror (errno));
+        }         
+      msg = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+
+      tmp = launch_data_new_string("SSH_AGENT_PID");
+      launch_data_dict_insert(msg, tmp, "UnsetUserEnvironment");
+
+      resp = launch_msg(msg);
+      launch_data_free(msg); // Do NOT launch_data_free() on tmp
+
+      if (resp) 
+        {
+          launch_data_free(resp);
+        } 
+      else
+        {
+          log_error ("failed to remove environment variable SSH_AGENT_PID from launchd: %s\n", strerror (errno));
+        }         
+    }
+#endif
 }
 
 
@@ -561,6 +628,9 @@
   int nogreeting = 0;
   int pipe_server = 0;
   int is_daemon = 0;
+#ifdef HAVE_LAUNCH
+  int launchd_child = 0;
+#endif
   int nodetach = 0;
   int csh_style = 0;
   char *logfile = NULL;
@@ -777,6 +847,9 @@
         case oSh: csh_style = 0; break;
         case oServer: pipe_server = 1; break;
         case oDaemon: is_daemon = 1; break;
+#ifdef HAVE_LAUNCH
+        case oLaunchd: launchd_child = 1; break;
+#endif
 
         case oDisplay: default_display = xstrdup (pargs.r.ret_str); break;
         case oTTYname: default_ttyname = xstrdup (pargs.r.ret_str); break;
@@ -812,6 +885,19 @@
         default : pargs.err = configfp? 1:2; break;
 	}
     }
+    
+  /* When running under launchd control, only start for real users ie UID >= 500
+     Do this check early to avoid filling logs */
+
+  /* HAVE_LAUNCH implies non-Windows system */
+#ifdef HAVE_LAUNCH
+  if (1 == launchd_child && geteuid() < 500)
+    {
+      log_error ("launchd only supported for real users - ie UID >= 500\n");
+      exit (1);
+    }     
+#endif
+
   if (configfp)
     {
       fclose( configfp );
@@ -932,7 +1018,11 @@
   /* If this has been called without any options, we merely check
      whether an agent is already running.  We do this here so that we
      don't clobber a logfile but print it directly to stderr. */
+#ifdef HAVE_LAUNCH
+  if (!pipe_server && !is_daemon && !launchd_child)
+#else
   if (!pipe_server && !is_daemon)
+#endif
     {
       log_set_prefix (NULL, JNLIB_LOG_WITH_PREFIX); 
       check_for_running_agent (0, 0);
@@ -994,6 +1084,186 @@
       agent_deinit_default_ctrl (ctrl);
       xfree (ctrl);
     }
+#ifdef HAVE_LAUNCH
+  else if (launchd_child)
+    { /* Launchd-compatible mode */
+      gnupg_fd_t fd;
+      gnupg_fd_t fd_ssh;
+      pid_t pid;
+
+      /* Remove the DISPLAY variable so that a pinentry does not
+         default to a specific display.  There is still a default
+         display when gpg-agent was started using --display or a
+         client requested this using an OPTION command.  Note, that we
+         don't do this when running in reverse daemon mode (i.e. when
+         exec the program given as arguments). */
+#ifndef HAVE_W32_SYSTEM
+      if (!opt.keep_display && !argc)
+        unsetenv ("DISPLAY");
+#endif
+
+      /* Create the sockets.  */
+      socket_name = create_socket_name ("S.gpg-agent",
+                                        "/tmp/gpg-XXXXXX/S.gpg-agent");
+      if (opt.ssh_support)
+	socket_name_ssh = create_socket_name ("S.gpg-agent.ssh",
+                                            "/tmp/gpg-XXXXXX/S.gpg-agent.ssh");
+
+      fd = create_server_socket (socket_name, 0, &socket_nonce);
+      if (opt.ssh_support)
+	fd_ssh = create_server_socket (socket_name_ssh, 1, &socket_nonce_ssh);
+      else
+	fd_ssh = GNUPG_INVALID_FD;
+
+      fflush (NULL);
+#ifdef HAVE_W32_SYSTEM
+      pid = getpid ();
+      printf ("set GPG_AGENT_INFO=%s;%lu;1\n", socket_name, (ulong)pid);
+#else /*!HAVE_W32_SYSTEM*/
+      pid = getpid ();
+
+          char *infostr, *infostr_ssh_sock, *infostr_ssh_pid;
+          
+          /* Create the info string: <name>:<pid>:<protocol_version> */
+          if (asprintf (&infostr, "GPG_AGENT_INFO=%s:%lu:1",
+                        socket_name, (ulong)pid ) < 0)
+            {
+              log_error ("out of core\n");
+              kill (pid, SIGTERM);
+              exit (1);
+            }
+	  if (opt.ssh_support)
+	    {
+	      if (asprintf (&infostr_ssh_sock, "SSH_AUTH_SOCK=%s",
+			    socket_name_ssh) < 0)
+		{
+		  log_error ("out of core\n");
+		  kill (pid, SIGTERM);
+		  exit (1);
+		}
+	      if (asprintf (&infostr_ssh_pid, "SSH_AGENT_PID=%u",
+			    pid) < 0)
+		{
+		  log_error ("out of core\n");
+		  kill (pid, SIGTERM);
+		  exit (1);
+		}
+	    }
+
+          if (env_file_name)
+            {
+              FILE *fp;
+              
+              fp = fopen (env_file_name, "w");
+              if (!fp)
+                log_error (_("error creating `%s': %s\n"),
+                             env_file_name, strerror (errno));
+              else
+                {
+                  fputs (infostr, fp);
+                  putc ('\n', fp);
+                  if (opt.ssh_support)
+                    {
+                      fputs (infostr_ssh_sock, fp);
+                      putc ('\n', fp);
+                      fputs (infostr_ssh_pid, fp);
+                      putc ('\n', fp);
+                    }
+                  fclose (fp);
+                }
+            }
+
+          // Pass environment variables back to launchd.
+          launch_data_t resp, tmp, tmpv, msg;
+    
+          msg = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+          tmp = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+    
+          tmpv = launch_data_new_string(strchr(infostr, '=') + 1); // Skip variable name and equal sign
+          launch_data_dict_insert(tmp, tmpv, "GPG_AGENT_INFO");
+          launch_data_dict_insert(msg, tmp, "SetUserEnvironment");
+    
+          resp = launch_msg(msg);
+          launch_data_free(msg); // Do NOT launch_data_free() on tmp, nor tmpv
+    
+          if (resp) 
+            {
+              launch_data_free(resp);
+            } 
+          else
+            {
+              log_error ("failed to pass environment variable GPG_AGENT_INFO to launchd: %s\n", strerror (errno));
+              kill (pid, SIGTERM);
+              exit (1);
+            }         
+        
+          if (opt.ssh_support)
+            {
+              msg = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+              tmp = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+        
+              tmpv = launch_data_new_string(strchr(infostr_ssh_sock, '=') + 1); // Skip variable name and equal sign
+              launch_data_dict_insert(tmp, tmpv, "SSH_AUTH_SOCK");
+              launch_data_dict_insert(msg, tmp, "SetUserEnvironment");
+        
+              resp = launch_msg(msg);
+              launch_data_free(msg); // Do NOT launch_data_free() on tmp, nor tmpv
+        
+              if (resp) 
+                {
+                  launch_data_free(resp);
+                } 
+              else
+                {
+                  log_error ("failed to pass environment variable SSH_AUTH_SOCK to launchd: %s\n", strerror (errno));
+                  kill (pid, SIGTERM);
+                  exit (1);
+                }         
+              msg = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+              tmp = launch_data_alloc(LAUNCH_DATA_DICTIONARY);
+        
+              tmpv = launch_data_new_string(strchr(infostr_ssh_pid, '=') + 1); // Skip variable name and equal sign
+              launch_data_dict_insert(tmp, tmpv, "SSH_AGENT_PID");
+              launch_data_dict_insert(msg, tmp, "SetUserEnvironment");
+        
+              resp = launch_msg(msg);
+              launch_data_free(msg); // Do NOT launch_data_free() on tmp, nor tmpv
+        
+              if (resp) 
+                {
+                  launch_data_free(resp);
+                } 
+              else
+                {
+                  log_error ("failed to pass environment variable SSH_AGENT_PID to launchd: %s\n", strerror (errno));
+                  kill (pid, SIGTERM);
+                  exit (1);
+                }         
+            }
+
+
+      {
+        struct sigaction sa;
+        
+        sa.sa_handler = SIG_IGN;
+        sigemptyset (&sa.sa_mask);
+        sa.sa_flags = 0;
+        sigaction (SIGPIPE, &sa, NULL);
+      }
+#endif /*!HAVE_W32_SYSTEM*/
+
+      handle_connections (fd, opt.ssh_support ? fd_ssh : GNUPG_INVALID_FD);
+
+      if (env_file_name)
+        {
+          if (unlink(env_file_name))
+            log_error (_("error deleting `%s': %s\n"),
+                         env_file_name, strerror (errno));
+        }
+
+      assuan_sock_close (fd);
+    }
+#endif /*HAVE_LAUNCH*/
   else if (!is_daemon)
     ; /* NOTREACHED */
   else
diff -ru agent/gpg-agent.c agent/gpg-agent.c
--- agent/gpg-agent.c	2011-01-09 23:06:14.000000000 +0100
+++ agent/gpg-agent.c	2011-12-22 12:45:02.000000000 +0100
@@ -322,7 +332,7 @@
 
   switch (level)
     {
-    case 11: p = "gpg-agent (GnuPG)";
+    case 11: p = "gpg-agent (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru agent/preset-passphrase.c agent/preset-passphrase.c
--- agent/preset-passphrase.c	2011-01-09 23:06:14.000000000 +0100
+++ agent/preset-passphrase.c	2011-12-22 12:45:02.000000000 +0100
@@ -87,7 +87,7 @@
   const char *p;
   switch (level)
     {
-    case 11: p = "gpg-preset-passphrase (GnuPG)";
+    case 11: p = "gpg-preset-passphrase (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru agent/protect-tool.c agent/protect-tool.c
--- agent/protect-tool.c	2011-01-09 23:06:14.000000000 +0100
+++ agent/protect-tool.c	2011-12-22 12:45:02.000000000 +0100
@@ -156,7 +156,7 @@
   const char *p;
   switch (level)
     {
-    case 11: p = "gpg-protect-tool (GnuPG)";
+    case 11: p = "gpg-protect-tool (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru doc/gnupg.info-1 doc/gnupg.info-1
--- doc/gnupg.info-1	2011-01-13 16:03:35.000000000 +0100
+++ doc/gnupg.info-1	2011-12-22 12:45:02.000000000 +0100
@@ -1235,7 +1235,7 @@
 3 Invoking GPG
 **************
 
-`gpg2' is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a
+`gpg2' is the OpenPGP part of the GNU Privacy Guard (GnuPG/MacGPG2). It is a
 tool to provide digital encryption and signing services using the
 OpenPGP standard. `gpg2' features complete key management and all bells
 and whistles you can expect from a decent OpenPGP implementation.
@@ -1709,7 +1709,7 @@
           Create a photographic user ID. This will prompt for a JPEG
           file that will be embedded into the user ID. Note that a very
           large JPEG will make for a very large key. Also note that
-          some programs will display your JPEG unchanged (GnuPG), and
+          some programs will display your JPEG unchanged (GnuPG/MacGPG2), and
           some programs will scale it to fit in a dialog box (PGP).
 
     showphoto



diff -ru doc/gpg.texi doc/gpg.texi
--- doc/gpg.texi	2011-01-13 15:27:27.000000000 +0100
+++ doc/gpg.texi	2011-12-22 12:45:02.000000000 +0100
@@ -65,7 +65,7 @@
 @c Begin GnuPG 2 specific stuff
 
 @mansect description
-@command{@gpgname} is the OpenPGP part of the GNU Privacy Guard (GnuPG). It
+@command{@gpgname} is the OpenPGP part of the GNU Privacy Guard (GnuPG/MacGPG2). It
 is a tool to provide digital encryption and signing services using the
 OpenPGP standard. @command{@gpgname} features complete key management and
 all bells and whistles you can expect from a decent OpenPGP
@@ -669,7 +669,7 @@
 Create a photographic user ID. This will prompt for a JPEG file that
 will be embedded into the user ID. Note that a very large JPEG will make
 for a very large key. Also note that some programs will display your
-JPEG unchanged (GnuPG), and some programs will scale it to fit in a
+JPEG unchanged (GnuPG/MacGPG2), and some programs will scale it to fit in a
 dialog box (PGP).
 
 @item showphoto


diff -ru g10/armor.c g10/armor.c
--- g10/armor.c	2011-01-09 23:06:15.000000000 +0100
+++ g10/armor.c	2011-12-22 12:45:02.000000000 +0100
@@ -1078,7 +1078,7 @@
 	    iobuf_writestr(a,afx->eol);
 	    if( !opt.no_version )
 	      {
-		iobuf_writestr(a, "Version: GnuPG v"  VERSION " ("
+		iobuf_writestr(a, "Version: GnuPG/MacGPG2 v"  VERSION " ("
 			       PRINTABLE_OS_NAME ")" );
 		iobuf_writestr(a,afx->eol);
 	      }


diff -ru g10/gpg.c g10/gpg.c
--- g10/gpg.c	2011-01-09 23:06:16.000000000 +0100
+++ g10/gpg.c	2011-12-22 12:45:02.000000000 +0100
@@ -807,7 +807,7 @@
   const char *p;
 
     switch( level ) {
-      case 11: p = "gpg (GnuPG)";
+      case 11: p = "gpg (GnuPG/MacGPG2)";
 	break;
       case 13: p = VERSION; break;
       case 17: p = PRINTABLE_OS_NAME; break;


diff -ru g10/gpgv.c g10/gpgv.c
--- g10/gpgv.c	2011-01-09 23:06:16.000000000 +0100
+++ g10/gpgv.c	2011-12-22 12:45:02.000000000 +0100
@@ -107,7 +107,7 @@
 
   switch (level)
     {
-    case 11: p = "gpgv (GnuPG)";
+    case 11: p = "gpgv (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru kbx/kbxutil.c kbx/kbxutil.c
--- kbx/kbxutil.c	2011-01-09 23:06:17.000000000 +0100
+++ kbx/kbxutil.c	2011-12-22 12:45:02.000000000 +0100
@@ -106,7 +106,7 @@
 {
     const char *p;
     switch( level ) {
-      case 11: p = "kbxutil (GnuPG)";
+      case 11: p = "kbxutil (GnuPG/MacGPG2)";
 	break;
       case 13: p = VERSION; break;
       case 17: p = PRINTABLE_OS_NAME; break;


diff -ru keyserver/gpg2keys_mailto.in keyserver/gpg2keys_mailto.in
--- keyserver/gpg2keys_mailto.in	2011-01-09 23:06:17.000000000 +0100
+++ keyserver/gpg2keys_mailto.in	2011-12-22 12:45:02.000000000 +0100
@@ -25,7 +25,7 @@
 
 sub VERSION_MESSAGE ()
 {
-    print STDOUT "gpg2keys_mailto (GnuPG) @VERSION@\n";
+    print STDOUT "gpg2keys_mailto (GnuPG/MacGPG2) @VERSION@\n";
 }
 
 sub HELP_MESSAGE ()


diff -ru keyserver/gpg2keys_test.in keyserver/gpg2keys_test.in
--- keyserver/gpg2keys_test.in	2011-01-09 23:06:17.000000000 +0100
+++ keyserver/gpg2keys_test.in	2011-12-22 12:45:02.000000000 +0100
@@ -24,7 +24,7 @@
 
 sub VERSION_MESSAGE ()
 {
-    print STDOUT "gpg2keys_test (GnuPG) @VERSION@\n";
+    print STDOUT "gpg2keys_test (GnuPG/MacGPG2) @VERSION@\n";
 }
 
 sub HELP_MESSAGE ()


diff -ru keyserver/gpgkeys_curl.c keyserver/gpgkeys_curl.c
--- keyserver/gpgkeys_curl.c	2011-01-09 23:06:17.000000000 +0100
+++ keyserver/gpgkeys_curl.c	2011-12-22 12:45:02.000000000 +0100
@@ -124,7 +124,7 @@
   /* Kludge to implement standard GNU options.  */
   if (argc > 1 && !strcmp (argv[1], "--version"))
     {
-      printf ("gpgkeys_curl (GnuPG) %s\n", VERSION);
+      printf ("gpgkeys_curl (GnuPG/MacGPG2) %s\n", VERSION);
       printf ("Uses: %s\n", curl_version());
       return 0;
     }



diff -ru keyserver/gpgkeys_finger.c keyserver/gpgkeys_finger.c
--- keyserver/gpgkeys_finger.c	2011-01-09 23:06:17.000000000 +0100
+++ keyserver/gpgkeys_finger.c	2011-12-22 12:45:02.000000000 +0100
@@ -337,7 +337,7 @@
   /* Kludge to implement standard GNU options.  */
   if (argc > 1 && !strcmp (argv[1], "--version"))
     {
-      fputs ("gpgkeys_finger (GnuPG) " VERSION"\n", stdout);
+      fputs ("gpgkeys_finger (GnuPG/MacGPG2) " VERSION"\n", stdout);
       return 0;
     }
   else if (argc > 1 && !strcmp (argv[1], "--help"))


diff -ru keyserver/gpgkeys_hkp.c keyserver/gpgkeys_hkp.c
--- keyserver/gpgkeys_hkp.c	2011-01-09 23:06:17.000000000 +0100
+++ keyserver/gpgkeys_hkp.c	2011-12-22 12:45:02.000000000 +0100
@@ -565,7 +565,7 @@
   /* Kludge to implement standard GNU options.  */
   if (argc > 1 && !strcmp (argv[1], "--version"))
     {
-      printf ("gpgkeys_hkp (GnuPG) %s\n", VERSION);
+      printf ("gpgkeys_hkp (GnuPG/MacGPG2) %s\n", VERSION);
       printf ("Uses: %s\n", curl_version());
       return 0;
     }


diff -ru keyserver/gpgkeys_kdns.c keyserver/gpgkeys_kdns.c
--- keyserver/gpgkeys_kdns.c	2011-01-09 23:06:17.000000000 +0100
+++ keyserver/gpgkeys_kdns.c	2011-12-22 12:45:02.000000000 +0100
@@ -188,7 +188,7 @@
 static void 
 show_help (FILE *fp)
 {
-  fputs (PGM" (GnuPG) " VERSION"\n\n", fp);
+  fputs (PGM" (GnuPG/MacGPG2) " VERSION"\n\n", fp);
   fputs (" -h\thelp\n"
          " -V\tversion\n"
          " -o\toutput to this file\n"
@@ -233,7 +233,7 @@
   /* Kludge to implement standard GNU options.  */
   if (argc > 1 && !strcmp (argv[1], "--version"))
     {
-      fputs (PGM" (GnuPG) " VERSION"\n", stdout);
+      fputs (PGM" (GnuPG/MacGPG2) " VERSION"\n", stdout);
       return 0;
     }
   else if (argc > 1 && !strcmp (argv[1], "--help"))


diff -ru keyserver/gpgkeys_ldap.c keyserver/gpgkeys_ldap.c
--- keyserver/gpgkeys_ldap.c	2011-01-09 23:06:17.000000000 +0100
+++ keyserver/gpgkeys_ldap.c	2011-12-22 12:45:02.000000000 +0100
@@ -1794,7 +1794,7 @@
   /* Kludge to implement standard GNU options.  */
   if (argc > 1 && !strcmp (argv[1], "--version"))
     {
-      fputs ("gpgkeys_ldap (GnuPG) " VERSION"\n", stdout);
+      fputs ("gpgkeys_ldap (GnuPG/MacGPG2) " VERSION"\n", stdout);
       return 0;
     }
   else if (argc > 1 && !strcmp (argv[1], "--help"))


diff -ru scd/pcsc-wrapper.c scd/pcsc-wrapper.c
--- scd/pcsc-wrapper.c	2011-01-09 23:06:17.000000000 +0100
+++ scd/pcsc-wrapper.c	2011-12-22 12:45:02.000000000 +0100
@@ -53,7 +53,7 @@
 
 /* Allow for a standalone build. */
 #ifdef VERSION
-#define MYVERSION_LINE PGM " (GnuPG) " VERSION
+#define MYVERSION_LINE PGM " (GnuPG/MacGPG2) " VERSION
 #define BUGREPORT_LINE "\nReport bugs to <bug-gnupg@gnu.org>.\n"
 #else
 #define MYVERSION_LINE PGM 


diff -ru scd/scdaemon.c scd/scdaemon.c
--- scd/scdaemon.c	2011-01-09 23:06:17.000000000 +0100
+++ scd/scdaemon.c	2011-12-22 12:45:02.000000000 +0100
@@ -239,7 +239,7 @@
 
   switch (level)
     {
-    case 11: p = "scdaemon (GnuPG)";
+    case 11: p = "scdaemon (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru sm/gpgsm.c sm/gpgsm.c
--- sm/gpgsm.c	2011-01-09 23:06:17.000000000 +0100
+++ sm/gpgsm.c	2011-12-22 12:45:02.000000000 +0100
@@ -512,7 +512,7 @@
 
   switch (level)
     {
-    case 11: p = "gpgsm (GnuPG)";
+    case 11: p = "gpgsm (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru tools/ccidmon.c tools/ccidmon.c
--- tools/ccidmon.c	2011-01-09 23:06:17.000000000 +0100
+++ tools/ccidmon.c	2011-12-22 12:45:02.000000000 +0100
@@ -810,7 +810,7 @@
         }
       else if (!strcmp (*argv, "--version"))
         {
-          fputs (PGM " (GnuPG) " PACKAGE_VERSION "\n", stdout);
+          fputs (PGM " (GnuPG/MacGPG2) " PACKAGE_VERSION "\n", stdout);
           exit (0);
         }
       else if (!strcmp (*argv, "--help"))


diff -ru tools/gpg-check-pattern.c tools/gpg-check-pattern.c
--- tools/gpg-check-pattern.c	2011-01-09 23:06:17.000000000 +0100
+++ tools/gpg-check-pattern.c	2011-12-22 12:45:02.000000000 +0100
@@ -134,7 +134,7 @@
   const char *p;
   switch (level)
     {
-    case 11: p = "gpg-check-pattern (GnuPG)";
+    case 11: p = "gpg-check-pattern (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru tools/gpg-connect-agent.c tools/gpg-connect-agent.c
--- tools/gpg-connect-agent.c	2011-01-09 23:06:17.000000000 +0100
+++ tools/gpg-connect-agent.c	2011-12-22 12:45:02.000000000 +0100
@@ -174,7 +174,7 @@
 
   switch (level)
     {
-    case 11: p = "gpg-connect-agent (GnuPG)";
+    case 11: p = "gpg-connect-agent (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru tools/gpg-zip.in tools/gpg-zip.in
--- tools/gpg-zip.in	2010-12-27 15:54:17.000000000 +0100
+++ tools/gpg-zip.in	2011-12-22 12:45:02.000000000 +0100
@@ -90,7 +90,7 @@
       shift
       ;;
     --version)
-      echo "gpg-zip (GnuPG) $VERSION"
+      echo "gpg-zip (GnuPG/MacGPG2) $VERSION"
       exit 0
       ;;
     --gpg)


diff -ru tools/gpgconf.c tools/gpgconf.c
--- tools/gpgconf.c	2011-01-09 23:06:17.000000000 +0100
+++ tools/gpgconf.c	2011-12-22 12:45:02.000000000 +0100
@@ -95,7 +95,7 @@
 
   switch (level)
     {
-    case 11: p = "gpgconf (GnuPG)";
+    case 11: p = "gpgconf (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru tools/gpgsplit.c tools/gpgsplit.c
--- tools/gpgsplit.c	2011-01-09 23:06:17.000000000 +0100
+++ tools/gpgsplit.c	2011-12-22 12:45:02.000000000 +0100
@@ -81,7 +81,7 @@
   const char *p;
   switch (level)
     {
-    case 11: p = "gpgsplit (GnuPG)";
+    case 11: p = "gpgsplit (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru tools/gpgtar.c tools/gpgtar.c
--- tools/gpgtar.c	2011-01-11 19:03:12.000000000 +0100
+++ tools/gpgtar.c	2011-12-22 12:45:02.000000000 +0100
@@ -117,7 +117,7 @@
 
   switch (level)
     {
-    case 11: p = "gpgtar (GnuPG)";
+    case 11: p = "gpgtar (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru tools/make-dns-cert.c tools/make-dns-cert.c
--- tools/make-dns-cert.c	2011-01-09 23:06:17.000000000 +0100
+++ tools/make-dns-cert.c	2011-12-22 12:45:02.000000000 +0100
@@ -188,7 +188,7 @@
   else if(argc>1 && strcmp(argv[1],"--version")==0)
     {
 #if defined(HAVE_CONFIG_H) && defined(VERSION)
-      printf ("make-dns-cert (GnuPG) " VERSION "\n");
+      printf ("make-dns-cert (GnuPG/MacGPG2) " VERSION "\n");
 #else
       printf ("make-dns-cert gnupg-svn%d\n", atoi (10+"$Revision$"));
 #endif


diff -ru tools/symcryptrun.c tools/symcryptrun.c
--- tools/symcryptrun.c	2011-01-09 23:06:17.000000000 +0100
+++ tools/symcryptrun.c	2011-12-22 12:45:02.000000000 +0100
@@ -196,7 +196,7 @@
 
   switch (level)
     {
-    case 11: p = "symcryptrun (GnuPG)";
+    case 11: p = "symcryptrun (GnuPG/MacGPG2)";
       break;
     case 13: p = VERSION; break;
     case 17: p = PRINTABLE_OS_NAME; break;


diff -ru tools/watchgnupg.c tools/watchgnupg.c
--- tools/watchgnupg.c	2011-01-09 23:06:17.000000000 +0100
+++ tools/watchgnupg.c	2011-12-22 12:45:02.000000000 +0100
@@ -37,7 +37,7 @@
 
 /* Allow for a standalone build on most systems. */
 #ifdef VERSION
-#define MYVERSION_LINE PGM " (GnuPG) " VERSION
+#define MYVERSION_LINE PGM " (GnuPG/MacGPG2) " VERSION
 #define BUGREPORT_LINE "\nReport bugs to <bug-gnupg@gnu.org>.\n"
 #else
 #define MYVERSION_LINE PGM 
diff -ru g10/options.skel g10/options.skel
--- g10/options.skel	2011-01-09 23:06:16.000000000 +0100
+++ g10/options.skel	2011-12-22 12:45:02.000000000 +0100
@@ -166,7 +166,7 @@
 # no-include-attributes = do not include attribute IDs (aka "photo IDs")
 #                         when sending keys to the keyserver.
 
-#keyserver-options auto-key-retrieve
+keyserver-options auto-key-retrieve
 
 # Uncomment this line to display photo user IDs in key listings and
 # when a signature from a key with a photo is verified.
@@ -204,3 +204,32 @@
 # Use your MIME handler to view photos:
 # photo-viewer "metamail -q -d -b -c %T -s 'KeyID 0x%k' -f GnuPG"
 
+#  *** Options for GPGTools ***
+
+# Automatic key location
+#
+# GnuPG can automatically locate and retrieve keys as needed using the
+# auto-key-locate option.  This happens when encrypting to an email
+# address (in the "user@example.com" form), and there are no
+# user@example.com keys on the local keyring.  This option takes the
+# following arguments, in the order they are to be tried:
+#
+# cert = locate a key using DNS CERT, as specified in RFC-4398.
+#        GnuPG can handle both the PGP (key) and IPGP (URL + fingerprint)
+#        CERT methods.
+#
+# pka = locate a key using DNS PKA.
+#
+# ldap = locate a key using the PGP Universal method of checking
+#        "ldap://keys.(thedomain)".  For example, encrypting to
+#        user@example.com will check ldap://keys.example.com.
+#
+# keyserver = locate a key using whatever keyserver is defined using
+#             the keyserver option.
+#
+# You may also list arbitrary keyservers here by URL.
+#
+# Try CERT, then PKA, then LDAP, then hkp://keys.gnupg.net:
+auto-key-locate cert pka ldap hkp://keys.gnupg.net
+
+comment GPGTools - http://gpgtools.org
